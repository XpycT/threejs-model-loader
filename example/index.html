<!DOCTYPE html>
<html>
<head>
	<title>THREEjs Model Loader</title>

	<script src="../node_modules/jszip/dist/jszip.min.js"></script>
	<script src="../node_modules/three/build/three.min.js"></script>
	<script src="../node_modules/three/examples/js/libs/inflate.min.js"></script>
	<script src="../node_modules/three/examples/js/loaders/AssimpLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/ColladaLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/FBXLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/KMZLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/OBJLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/PLYLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/PCDLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/STLLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/VTKLoader.js"></script>
	<script src="../node_modules/collada-archive-loader/ColladaArchiveLoader.js"></script>

	<script src="../ModelLoader.js"></script>
	<script src="./ZipServer.js"></script>

	<style>
		* {
			margin: 0;
			padding: 0;
			overflow: hidden;
		}

		#container {
			position: absolute;
			width: 100%;
		}

		#container > * {
			padding: 5px;
		}

		#error {
			background: #E91E63;
		}

		#error:empty {
			padding: 0;
		}

		div {
			color: white;
			text-align: center;
			pointer-events: none;
			font-family:Monospace;
			font-size:13px;
		}
	</style>
</head>
<body>
	<div id="container">
		<div id="error"></div>
		<div>Drag geometry files and depencies to load and view them </br>
		( Dragging folders will only work in chrome )</div>
	</div>
	
	<script>

		// Renderer and scene setup
		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );
		camera.position.set( 4, 5, 4 );
		camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );

		const ambientLight = new THREE.AmbientLight( 0xcccccc, 0.4 );
		scene.add( ambientLight );

		const directionalLight = new THREE.DirectionalLight();
		directionalLight.position.set( 1, 1, 0 ).normalize();
		scene.add( directionalLight );

		const rotator = new THREE.Object3D();
		scene.add( rotator );

		const renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setClearColor( 0x263238 );
		document.body.appendChild( renderer.domElement );


		// overriding the getLoader function so loaders can be
		// loaded as-needed
		const errorel = document.getElementById( 'error' );
		const loader = new THREE.ModelLoader();
		loader.getLoader = function ( loaderName, manager, loadercb ) {

			function createLoader() {

				return new THREE[ loaderName ]( manager );

			}

			function getSource( name ) {
				
				let f =
					fetch( `../node_modules/three/examples/js/loaders/${ name }.js` )
						.then( res => res.text() )
				f.then( text => eval( text ) );

				return f;

			}

			if ( THREE[ loaderName ] == null ) {


				if ( loaderName === 'OBJLoader2' ) {

					getSource( 'LoaderSupport' )
						.then(() => getSource( loaderName ))
						.then(() => loadercb( createLoader() ));

				} else if ( loaderName === 'KMZLoader' ) {

					getSource( 'ColladaLoader' )
						.then(() => getSource( loaderName ))
						.then(() => loadercb( createLoader() ));

				} else {

					getSource( loaderName )
						.then(() => loadercb( createLoader() ));
				}

			} else {

				loadercb( createLoader() );

			}

		};
		
		// Create a zip file and add it to the zip server so extra
		// files can be added
		// Folders can only be added if working in Chrome
		function createZip( dtitems ) {

			return new Promise( resolve => {

				// keep track of how many async file read operations we
				// do so we know when they've all finished
				let ct = 0;

				// iterate down the file tree, firing a callback for every file
				function recurseDirectory(item, filecb) {

					if (item.isFile) {

						filecb(item);

					} else {

						let reader = item.createReader();
						reader.readEntries(et => {
							et.forEach(e => {
								recurseDirectory(e, filecb);
							});
						})

					}

				}

				// Traverse down the tree and add the files into the zip
				if (dtitems && dtitems.length && dtitems[0].webkitGetAsEntry) {
				
					let zip = new JSZip();
					for (let i = 0; i < dtitems.length; i ++) {
						let item = dtitems[i];

						let entry = item.webkitGetAsEntry();
						recurseDirectory(entry, f => {

							ct ++;
							f.file(res => {
								let fr = new FileReader();
								fr.onload = e => {

									zip.file(f.fullPath, e.target.result);
									ct --;
									if (ct === 0) resolve(zip.generate({ type:"arraybuffer" }));

								}
								fr.readAsArrayBuffer(res);
							});

						});

					}
				} else {

					requestAnimationFrame(() => resolve(null));

				}
			});

		}

		// Load the model into the scene. Returns a promise that resolves with a file extension
		// if the file was unable to load. Null otherwise
		function loadModel(file) {

			return new Promise( resolve => {

				let extmatches = file.name.match( /\.([^\.\\\/]+)$/ );
				if (extmatches) {
				
					// load the file
					let ext = extmatches[ 1 ];
					let url = URL.createObjectURL( file );
					fetch( url )
						.then(res => res.text())
						.then(data => {

							URL.revokeObjectURL( url );

							// parse the file
							loader.parse( data, ext, m => {

								// disambiguate the file to add between all the
								// parsers. (TODO: Should this be in the main loader?)
								let mat = new THREE.MeshLambertMaterial({ color: 0xffffff, vertexColors: THREE.VertexColors });
								let obj = m.scene || m.object || m;
								obj = obj instanceof THREE.BufferGeometry ? new THREE.Mesh(obj, mat) : obj;
								obj = obj instanceof THREE.Geometry ? new THREE.Mesh(obj, mat) : obj;

								// Get the bounds of the model and scale and set appropriately
								obj.updateMatrixWorld( true );
								let sphere = new THREE.Box3().expandByObject(obj).getBoundingSphere();
								let s = 3 / sphere.radius;

								obj.position.set(0, 0, 0);
								obj.position.sub(sphere.center);
								obj.position.divideScalar(2);
								obj.scale.set( s, s, s );

								rotator.add( obj );

								resolve(null);
							
							}, err => resolve(ext));

						} );	
				}

			});

		}
 

		let zipserver = new ZipServer();
		zipserver.register();

		document.addEventListener( 'dragover', e => e.preventDefault() );
		document.addEventListener( 'dragenter', e => e.preventDefault() );
		document.addEventListener( 'drop', e => {

			e.preventDefault();

			// Clear the scene and error before loading
			while (rotator.children.length) rotator.remove(rotator.children[0]);
			errorel.innerText = '';

			// Create the zip
			let dtfiles = [...e.dataTransfer.files];
			let zipHandle = null;
			createZip(e.dataTransfer.items)
				.then(buff => {

					if ( buff ) zipHandle = zipserver.add(buff);

					let promises = dtfiles.map(file => loadModel( file ));

					// Load the model and report an error if nothing could
					// be displayed
					Promise
						.all(promises)
						.then(res => {

							const success = res.indexOf(null) !== -1;
							if (!success) { 

								const extensions = res
									.reduce((acc, val) => {
										if ( acc.indexOf(val) === -1 ) acc.push(val);
										return acc;
									}, []);

								const str = extensions.map(e => `'${ e }'`).join(',');
								errorel.innerText = `Model Loader : No loader specified for ${ extensions }`;

							}

							if (zipHandle) {

								setTimeout(() => zipHandle.dispose(), 100);

							}
						})

				} );

		} );

		window.addEventListener( 'resize', () => {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		} );

		( function renderLoop() {

			rotator.rotateY( 0.001 );
			renderer.render( scene, camera );
			requestAnimationFrame( renderLoop );

		} )();


	</script>
</body>
</html>
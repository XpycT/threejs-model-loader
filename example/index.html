<!DOCTYPE html>
<html>
<head>
	<title>THREEjs Model Loader</title>

	<script src="../node_modules/jszip/dist/jszip.min.js"></script>
	<script src="../node_modules/three/build/three.min.js"></script>
	<script src="../node_modules/three/examples/js/libs/inflate.min.js"></script>
	<script src="../node_modules/three/examples/js/loaders/3MFLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/AMFLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/AssimpLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/AssimpJSONLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/ColladaLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/FBXLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/KMZLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/OBJLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/PLYLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/PCDLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/STLLoader.js"></script>
	<script src="../node_modules/three/examples/js/loaders/VTKLoader.js"></script>
	<script src="../node_modules/collada-archive-loader/ColladaArchiveLoader.js"></script>

	<script src="../ModelLoader.js"></script>
	<script src="./ZipServer.js"></script>

	<style>
		* {
			margin: 0;
			padding: 0;
			overflow: hidden;
		}

		#container {
			position: absolute;
			width: 100%;
		}

		#container > * {
			padding: 5px;
		}

		#error {
			background: #E91E63;
		}

		#error:empty {
			padding: 0;
		}

		div {
			color: white;
			text-align: center;
			pointer-events: none;
			font-family:Monospace;
			font-size:13px;
		}
	</style>
</head>
<body>
	<div id="container">
		<div id="error"></div>
		<div>Drag geometry files and depencies to load and view them </br>
		( Dragging folders will only work in chrome )</div>
	</div>
	
	<script>

		const bgColors = [
			0xFFC107,
			0xF06292,
			0x009688,
			0x3F51B5,
			0xCDDC39
		]

		// Renderer and scene setup
		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 2000 );
		camera.position.set( 0, 3, 6.5 );
		camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );

		const ambientLight = new THREE.AmbientLight( 0xcccccc, 0.4 );
		scene.add( ambientLight );

		const directionalLight = new THREE.DirectionalLight();
		directionalLight.position.set( 10, 10, 0 );
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.castShadow = true;
		scene.add( directionalLight );

		const scaleContainer = new THREE.Object3D();
		scene.add(scaleContainer);

		const rotator = new THREE.Object3D();
		scaleContainer.add( rotator );

		const plane = new THREE.Mesh(
			new THREE.PlaneGeometry(),
			new THREE.ShadowMaterial({ side: THREE.DoubleSide, transparent: true, opacity: 0.25 })
		);
		plane.rotation.set(-Math.PI / 2, 0, 0);
		plane.scale.multiplyScalar(20);
		plane.receiveShadow = true;
		scaleContainer.add(plane);

		const renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setClearColor( bgColors[0] );
		renderer.shadowMap.enabled = true;
		document.body.appendChild( renderer.domElement );


		// overriding the getLoader function so loaders can be
		// loaded as-needed
		const errorel = document.getElementById( 'error' );
		const manager = new THREE.LoadingManager();
		const loader = new THREE.ModelLoader( manager );
		loader.getLoader = function ( loaderName, manager, loadercb ) {

			function createLoader( ln ) {

				ln = ln || loaderName;

				return new THREE[ ln ]( manager );

			}

			function getSource( name ) {
				
				let f =
					fetch( `../node_modules/three/examples/js/loaders/${ name }.js` )
						.then( res => res.text() )
				f.then( text => eval( text ) );

				return f;

			}

			if ( THREE[ loaderName ] == null ) {

				if ( loaderName === 'OBJLoader2' ) {

					getSource( 'LoaderSupport' )
						.then(() => getSource( loaderName ))
						.then(() => loadercb( createLoader() ));

				} else if ( loaderName === 'KMZLoader' ) {

					getSource( 'ColladaLoader' )
						.then(() => getSource( loaderName ))
						.then(() => loadercb( createLoader() ));

				} else if ( loaderName === '3MFLoader') {

					getSource( loaderName )
						.then(() => loadercb( createLoader( 'ThreeMFLoader' ) ));

				} else {

					getSource( loaderName )
						.then(() => loadercb( createLoader() ));
				}

			} else {

				loadercb( createLoader() );

			}

		};

		// Load the model into the scene. Returns a promise that resolves with a file extension
		// if the file was unable to load. Null otherwise
		function loadModel( file ) {

			return new Promise( resolve => {
				
				// The file name will be able to be loaded from the
				// zip server
				const name = file.name
				loader.load( name, m => {

					// disambiguate the file to add between all the parsers.
					const mat = new THREE.MeshBasicMaterial( { color: 0xffffff } );
					let obj = m.scene || m.object || m;
					obj = obj instanceof THREE.BufferGeometry || obj instanceof THREE.Geometry
							? new THREE.Mesh( obj, mat ) : obj;

					// Get the bounds of the model and scale and set appropriately
					obj.updateMatrixWorld( true );
					const box = new THREE.Box3().expandByObject( obj );
					const sphere = box.getBoundingSphere( new THREE.Sphere() );
					const s = 3 / sphere.radius;

					rotator.add( obj );
					rotator.rotation.set( 0, 0, 0 );
					obj.position
						.copy( sphere.center )
						.negate();

					scaleContainer.scale.set( 1, 1, 1 ).multiplyScalar( s );

					plane.position.y = obj.position.y + box.min.y;
					plane
						.scale
						.set( 1, 1, 1 )
						.multiplyScalar( 100 / s );

					obj.traverse(c => {

						if ( 'castShadow' in c ) c.castShadow = true;

						if ( c instanceof THREE.Mesh ) {

							if ( c.material instanceof THREE.MeshBasicMaterial ) {

								console.log(c);
								const mat = new THREE.MeshPhongMaterial({ color: 0x888888 });
								if ( c.geometry instanceof THREE.BufferGeometry && 'color' in c.geometry.attributes
									|| c.geometry instanceof THREE.Geometry ) {

									mat.vertexColors = THREE.VertexColors;

								}

								if ( c.geometry instanceof THREE.BufferGeometry && !( 'normal' in c.geometry.attributes )) {

									c.geometry.computeVertexNormals();

								}

								c.material = mat;

							}

						}

					});

					resolve(null);
				
				}, null, err => {
				
					resolve(err);
				
				});

			});

		}
 
		document.addEventListener( 'dragover', e => e.preventDefault() );
		document.addEventListener( 'dragenter', e => e.preventDefault() );
		document.addEventListener( 'drop', e => {

			e.preventDefault();

			// Clear the scene and error before loading
			while (rotator.children.length) rotator.remove(rotator.children[0]);
			errorel.innerText = '';

			const newcol = bgColors.shift();
			bgColors.push(newcol);
			ambientLight.color.set(newcol).lerp(new THREE.Color(0xffffff), 0.7);
			renderer.setClearColor(newcol);

			// Create the zip
			// TODO: Packing and then unpacking data to and from a zip that we
			// already have as a blob is not the most efficient way of loading
			// these files
			let dtfiles = [...e.dataTransfer.files];
			ZipServer
				._dataTransferToZip(e.dataTransfer)
				.then(buffer => new JSZip(buffer))
				.then(zip => {

					manager.setURLModifier(url => {

						url = url.replace(/^[\.\\\/]*/, '');

						const files = zip.file(new RegExp(url));
						if (files.length) {

							const ab = files.pop().asArrayBuffer();
							const newurl = URL.createObjectURL( new Blob( [ab] ) );

							requestAnimationFrame(() => URL.revokeObjectURL(newurl));

							return newurl;

						}

						return url;
					})

					requestAnimationFrame( () => {
						let promises = dtfiles.map(file => loadModel( file ));

						// Load the model and report an error if nothing could
						// be displayed
						Promise
							.all(promises)
							.then( res => {

								loader.clearCache();

								const success = res.indexOf(null) !== -1;
								if (!success) { 

									console.log(res)
									errorel.innerText = res.join('\n');

								}

								manager.setURLModifier(null);

							} );
					} );

				} );

		} );

		window.addEventListener( 'resize', () => {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		} );

		( function renderLoop() {

			rotator.rotateY( 0.005 );
			renderer.render( scene, camera );
			requestAnimationFrame( renderLoop );

		} )();


	</script>
</body>
</html>